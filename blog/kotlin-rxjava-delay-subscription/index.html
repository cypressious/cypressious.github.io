<!DOCTYPE html>
<html data-html-server-rendered="true" lang="en" data-vue-tag="%7B%22lang%22:%7B%22ssr%22:%22en%22%7D%7D">
  <head>
    <title>RxJava &amp; Kotlin: Conditionally delaying the first item in a stream - Kirill Rakhman</title><meta name="gridsome:hash" content="6a942ed5c048ddade2bf5e137405aa177d377427"><meta data-vue-tag="ssr" charset="utf-8"><meta data-vue-tag="ssr" name="generator" content="Gridsome v0.7.23"><meta data-vue-tag="ssr" data-key="viewport" name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"><meta data-vue-tag="ssr" data-key="format-detection" name="format-detection" content="telephone=no"><meta data-vue-tag="ssr" name="viewport" content="width=device-width, initial-scale=1"><meta data-vue-tag="ssr" name="google-site-verification" content="iUq6VtnS5zRh-s4b27kdrA1sx9a1YdgEr35fwUd4lGg"><meta data-vue-tag="ssr" data-key="description" name="description" content="Using a Kotlin Extension Function to solve an RxJava problem"><link data-vue-tag="ssr" rel="icon" href="data:,"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="16x16" href="/assets/static/favicon.ce0531f.4a56f7a3661904998f7ebc492669c703.png"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="32x32" href="/assets/static/favicon.ac8d93a.4a56f7a3661904998f7ebc492669c703.png"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="96x96" href="/assets/static/favicon.b9532cc.4a56f7a3661904998f7ebc492669c703.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="76x76" href="/assets/static/favicon.f22e9f3.4a56f7a3661904998f7ebc492669c703.png"><link data-vue-tag="ssr" rel="alternate" type="application/rss+xml" title="RSS Feed for Kirill Rakhman&#x27;s Dev Blog" href="/rss.xml"><link rel="preload" href="/assets/css/0.styles.44ee10b9.css" as="style"><link rel="preload" href="/assets/js/app.55ecf81a.js" as="script"><link rel="preload" href="/assets/js/page--src--templates--post-vue.85c2b142.js" as="script"><link rel="prefetch" href="/assets/js/page--node-modules--gridsome--app--pages--404-vue.63edb07b.js"><link rel="prefetch" href="/assets/js/page--src--pages--blog-vue.8a09a9a4.js"><link rel="prefetch" href="/assets/js/page--src--pages--cv-vue.f907f9c6.js"><link rel="prefetch" href="/assets/js/page--src--pages--gh-vue.e8449588.js"><link rel="prefetch" href="/assets/js/page--src--pages--index-vue.6d801ee0.js"><link rel="prefetch" href="/assets/js/page--src--pages--linkedin-vue.5d0ccbe0.js"><link rel="prefetch" href="/assets/js/page--src--pages--publications-vue.5926a3d2.js"><link rel="prefetch" href="/assets/js/page--src--pages--recipe-plan--privacy-policy-vue.672110f1.js"><link rel="prefetch" href="/assets/js/page--src--pages--so-vue.963d6a92.js"><link rel="prefetch" href="/assets/js/page--src--pages--talks-vue.90e74cf1.js"><link rel="prefetch" href="/assets/js/page--src--pages--twitter-vue.47130daf.js"><link rel="prefetch" href="/assets/js/page--src--pages--xing-vue.0ce994e5.js"><link rel="stylesheet" href="/assets/css/0.styles.44ee10b9.css"><noscript data-vue-tag="ssr"><style>.g-image--loading{display:none;}</style></noscript>
  </head>
  <body class="has-navbar-fixed-top" data-vue-tag="%7B%22class%22:%7B%22ssr%22:%22has-navbar-fixed-top%22%7D%7D">
    <div data-server-rendered="true" id="app" class="container" data-v-979f03f6 data-v-3c6fa87e><nav role="navigation" aria-label="main navigation" class="navbar is-fixed-top is-primary" data-v-979f03f6><div class="navbar-container container" data-v-979f03f6><div class="navbar-brand" data-v-979f03f6><a href="/" class="navbar-item" data-v-979f03f6><strong data-v-979f03f6>Kirill Rakhman</strong></a><a role="button" aria-label="menu" aria-expanded="false" class="navbar-burger burger" data-v-979f03f6><span aria-hidden="true" data-v-979f03f6></span><span aria-hidden="true" data-v-979f03f6></span><span aria-hidden="true" data-v-979f03f6></span></a></div><div class="navbar-menu" data-v-979f03f6><div class="navbar-start" data-v-979f03f6><a href="/cv/" class="navbar-item" data-v-979f03f6>CV</a><a href="/publications/" class="navbar-item" data-v-979f03f6>Publications</a><a href="/talks/" class="navbar-item" data-v-979f03f6>Talks</a><a href="/blog/" class="navbar-item is-active" data-v-979f03f6>Blog</a></div></div></div></nav><div class="container main-content" data-v-979f03f6><a href="/blog" class="is-active" data-v-3c6fa87e><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="arrow-left" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="svg-inline--fa fa-arrow-left" data-v-3c6fa87e><path fill="currentColor" d="M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.2 288 416 288c17.7 0 32-14.3 32-32s-14.3-32-32-32l-306.7 0L214.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z" data-v-3c6fa87e></path></svg>
        All Blog Posts
    </a><div class="post-title mb-2" data-v-979f03f6 data-v-3c6fa87e><h1 class="title" data-v-979f03f6 data-v-3c6fa87e>RxJava &amp; Kotlin: Conditionally delaying the first item in a stream</h1><p class="subtitle" data-v-979f03f6 data-v-3c6fa87e>
            25 May 2016
        </p></div><div class="content" data-v-979f03f6 data-v-3c6fa87e><p>In my application, I recently had the following requirement: In a reactive stream of items, wait until one specific item is emitted, then emit all items to the observer. If that item isn’t found, don’t emit anything and terminate with an error.</p>
<p>Now, RxJava has a number of useful operators like <code>buffer</code> or <code>delaySubscription</code> but they weren’t exactly doing the right thing. So I came up with a solution I want to share.</p>
<h2 id="the-code"><a href="#the-code" aria-hidden="true"><span class="hashtag"></span></a>The code</h2>
<p>Here’s the implementation, wrapped in an extension function:</p>
<pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> Observable<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">delayUntil</span><span class="token punctuation">(</span>value<span class="token operator">:</span> T<span class="token punctuation">)</span><span class="token operator">:</span> Observable<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">val</span> replaySubject <span class="token operator">=</span> ReplaySubject<span class="token punctuation">.</span>create<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">val</span> sharedObservable <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">publish</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">autoConnect</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
    sharedObservable<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>replaySubject<span class="token punctuation">)</span>

    <span class="token keyword">val</span> delayObservable <span class="token operator">=</span> sharedObservable
            <span class="token punctuation">.</span><span class="token function">first</span> <span class="token punctuation">{</span> it <span class="token operator">==</span> value <span class="token punctuation">}</span>
            <span class="token punctuation">.</span><span class="token function">concatWith</span><span class="token punctuation">(</span>Observable<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token function">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> replaySubject<span class="token punctuation">.</span><span class="token function">delaySubscription</span><span class="token punctuation">(</span>delayObservable<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>Let’s analyze what it’s doing:</p>
<p>Because the items in the stream aren’t delivered immediately at first, we buffer them in a <code>ReplaySubject</code>. As a reminder, a <code>Subject</code> is both, an <code>Observer</code> and an <code>Observable</code>. We make use of this by subscribing it directly to our item source in line 5. Once an observer subscribes to the <code>ReplaySubject</code>, it will emit all previous and future items to it.</p>
<p>We will need to subscribe to the source observable twice, first to feed the items into the <code>replaySubject</code> and second to check for the expected item. Because the source observable is potentially <a href="https://www.javacodegeeks.com/2015/03/hot-and-cold-rx-java-observable.html" target="_blank" rel="nofollow noopener noreferrer"><em>cold</em></a>, we don’t want to subscribe to it twice directly. Instead, we use the <code>publish</code> operator which will deliver the results from a single stream to all subscribers in combination with the <code>autoConnect</code> operator that makes the observable actually subscribe to the source once two observers are subscribed.</p>
<p>Next, in lines 7–9, we setup the <code>delayObservable</code> that either emits the first occurence of the expected item in the source stream or terminates with an error. Note, that even if it finds the item, it will still terminate with an error, however that is perfectly fine for our needs.</p>
<p>This return value of the method is the subject itself with the <code>delaySubscription</code> operator applied to it. This operator expects an observable parameter and waits until it emits any item or completes without emitting before it subscribes to the original observable. This is exactly, what the <code>delayObservable</code> is used for. In our case, if no item is emited, the error is propagated instead.</p>
<h2 id="examples"><a href="#examples" aria-hidden="true"><span class="hashtag"></span></a>Examples</h2>
<p>Let’s look at what the result looks like. We use a Semaphore so that our little test programs doesn’t instantly terminate. We create a source that emits 10 sequential numbers every 200 milliseconds. We delay it until we find a 3 and subscribe to it by printing the results with a timestamp.</p>
<pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> mutex <span class="token operator">=</span> <span class="token function">Semaphore</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token keyword">val</span> source <span class="token operator">=</span> Observable<span class="token punctuation">.</span><span class="token function">interval</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
<span class="token keyword">val</span> delayed <span class="token operator">=</span>  source<span class="token punctuation">.</span><span class="token function">delayUntil</span><span class="token punctuation">(</span><span class="token number">3L</span><span class="token punctuation">)</span>

<span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token expression">System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">: start"</span></span><span class="token punctuation">)</span>
delayed<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>
        <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token expression">System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">it</span></span><span class="token string">"</span></span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string-literal singleline"><span class="token string">"Failed with </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$</span><span class="token expression">it</span></span><span class="token string">"</span></span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span> mutex<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token punctuation">)</span>

mutex<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<p>And here’s the output:</p>
<pre class="language-text"><code class="language-text">1464210578099: start
1464210578909: 0
1464210578909: 1
1464210578909: 2
1464210578909: 3
1464210579106: 4
1464210579306: 5
1464210579506: 6
1464210579706: 7
1464210579906: 8
1464210580106: 9</code></pre>
<p>We can see that items 0 through 3 are buffered and then emitted all at once. After that, the remaining items are emitted immediately, just like we wanted to.</p>
<h2 id="making-the-observable-reusable"><a href="#making-the-observable-reusable" aria-hidden="true"><span class="hashtag"></span></a>Making the observable reusable</h2>
<p>Now what happens if we subscribe to the same delayed observable a second time? The answer is: nothing, it won’t even complete. The problem has to do with how <code>ConnectableObservables</code> work, but I will spare you the details.</p>
<p>Anyway, there’s an easy fix. We simply wrap the source with a call to <code>Observable.defer</code> to make it compute the results anew on every call:</p>
<pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> delayed <span class="token operator">=</span> Observable<span class="token punctuation">.</span><span class="token function">defer</span> <span class="token punctuation">{</span> source<span class="token punctuation">.</span><span class="token function">delayUntil</span><span class="token punctuation">(</span><span class="token number">3L</span><span class="token punctuation">)</span> <span class="token punctuation">}</span></code></pre>
<p>Alternatively, we can <code>cache</code> the output of the observable to prevent it from doing the same work twice like so:</p>
<pre class="language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> delayed <span class="token operator">=</span> source<span class="token punctuation">.</span><span class="token function">delayUntil</span><span class="token punctuation">(</span><span class="token number">3L</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">cache</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<p>In both cases, you can call the observables as many times as you want and get correct behavior.</p>
</div><hr class="mb-3" data-v-979f03f6 data-v-3c6fa87e><!----><!----><a href="/blog" class="is-active" data-v-3c6fa87e><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="arrow-left" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="svg-inline--fa fa-arrow-left" data-v-3c6fa87e><path fill="currentColor" d="M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.2 288 416 288c17.7 0 32-14.3 32-32s-14.3-32-32-32l-306.7 0L214.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z" data-v-3c6fa87e></path></svg>
        All Blog Posts
    </a></div></div>
    <script>window.__INITIAL_STATE__={"data":{"post":{"id":"050fa826b992fe9deebaab7763723d33","title":"RxJava & Kotlin: Conditionally delaying the first item in a stream","content":"\u003Cp\u003EIn my application, I recently had the following requirement: In a reactive stream of items, wait until one specific item is emitted, then emit all items to the observer. If that item isn’t found, don’t emit anything and terminate with an error.\u003C\u002Fp\u003E\n\u003Cp\u003ENow, RxJava has a number of useful operators like \u003Ccode\u003Ebuffer\u003C\u002Fcode\u003E or \u003Ccode\u003EdelaySubscription\u003C\u002Fcode\u003E but they weren’t exactly doing the right thing. So I came up with a solution I want to share.\u003C\u002Fp\u003E\n\u003Ch2 id=\"the-code\"\u003E\u003Ca href=\"#the-code\" aria-hidden=\"true\"\u003E\u003Cspan class=\"hashtag\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EThe code\u003C\u002Fh2\u003E\n\u003Cp\u003EHere’s the implementation, wrapped in an extension function:\u003C\u002Fp\u003E\n\u003Cpre class=\"language-kotlin\"\u003E\u003Ccode class=\"language-kotlin\"\u003E\u003Cspan class=\"token keyword\"\u003Efun\u003C\u002Fspan\u003E \u003Cspan class=\"token operator\"\u003E&lt;\u003C\u002Fspan\u003ET\u003Cspan class=\"token operator\"\u003E\u003E\u003C\u002Fspan\u003E Observable\u003Cspan class=\"token operator\"\u003E&lt;\u003C\u002Fspan\u003ET\u003Cspan class=\"token operator\"\u003E\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token function\"\u003EdelayUntil\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003Evalue\u003Cspan class=\"token operator\"\u003E:\u003C\u002Fspan\u003E T\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token operator\"\u003E:\u003C\u002Fspan\u003E Observable\u003Cspan class=\"token operator\"\u003E&lt;\u003C\u002Fspan\u003ET\u003Cspan class=\"token operator\"\u003E\u003E\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E\n    \u003Cspan class=\"token keyword\"\u003Eval\u003C\u002Fspan\u003E replaySubject \u003Cspan class=\"token operator\"\u003E=\u003C\u002Fspan\u003E ReplaySubject\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003Ecreate\u003Cspan class=\"token operator\"\u003E&lt;\u003C\u002Fspan\u003ET\u003Cspan class=\"token operator\"\u003E\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\n\n    \u003Cspan class=\"token keyword\"\u003Eval\u003C\u002Fspan\u003E sharedObservable \u003Cspan class=\"token operator\"\u003E=\u003C\u002Fspan\u003E \u003Cspan class=\"token keyword\"\u003Ethis\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token function\"\u003Epublish\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token function\"\u003EautoConnect\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token number\"\u003E2\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\n    sharedObservable\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token function\"\u003Esubscribe\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003EreplaySubject\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\n\n    \u003Cspan class=\"token keyword\"\u003Eval\u003C\u002Fspan\u003E delayObservable \u003Cspan class=\"token operator\"\u003E=\u003C\u002Fspan\u003E sharedObservable\n            \u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token function\"\u003Efirst\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E it \u003Cspan class=\"token operator\"\u003E==\u003C\u002Fspan\u003E value \u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\n            \u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token function\"\u003EconcatWith\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003EObservable\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token function\"\u003Eerror\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token function\"\u003EIllegalArgumentException\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\n\n    \u003Cspan class=\"token keyword\"\u003Ereturn\u003C\u002Fspan\u003E replaySubject\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token function\"\u003EdelaySubscription\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003EdelayObservable\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\n\u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003ELet’s analyze what it’s doing:\u003C\u002Fp\u003E\n\u003Cp\u003EBecause the items in the stream aren’t delivered immediately at first, we buffer them in a \u003Ccode\u003EReplaySubject\u003C\u002Fcode\u003E. As a reminder, a \u003Ccode\u003ESubject\u003C\u002Fcode\u003E is both, an \u003Ccode\u003EObserver\u003C\u002Fcode\u003E and an \u003Ccode\u003EObservable\u003C\u002Fcode\u003E. We make use of this by subscribing it directly to our item source in line 5. Once an observer subscribes to the \u003Ccode\u003EReplaySubject\u003C\u002Fcode\u003E, it will emit all previous and future items to it.\u003C\u002Fp\u003E\n\u003Cp\u003EWe will need to subscribe to the source observable twice, first to feed the items into the \u003Ccode\u003EreplaySubject\u003C\u002Fcode\u003E and second to check for the expected item. Because the source observable is potentially \u003Ca href=\"https:\u002F\u002Fwww.javacodegeeks.com\u002F2015\u002F03\u002Fhot-and-cold-rx-java-observable.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003E\u003Cem\u003Ecold\u003C\u002Fem\u003E\u003C\u002Fa\u003E, we don’t want to subscribe to it twice directly. Instead, we use the \u003Ccode\u003Epublish\u003C\u002Fcode\u003E operator which will deliver the results from a single stream to all subscribers in combination with the \u003Ccode\u003EautoConnect\u003C\u002Fcode\u003E operator that makes the observable actually subscribe to the source once two observers are subscribed.\u003C\u002Fp\u003E\n\u003Cp\u003ENext, in lines 7–9, we setup the \u003Ccode\u003EdelayObservable\u003C\u002Fcode\u003E that either emits the first occurence of the expected item in the source stream or terminates with an error. Note, that even if it finds the item, it will still terminate with an error, however that is perfectly fine for our needs.\u003C\u002Fp\u003E\n\u003Cp\u003EThis return value of the method is the subject itself with the \u003Ccode\u003EdelaySubscription\u003C\u002Fcode\u003E operator applied to it. This operator expects an observable parameter and waits until it emits any item or completes without emitting before it subscribes to the original observable. This is exactly, what the \u003Ccode\u003EdelayObservable\u003C\u002Fcode\u003E is used for. In our case, if no item is emited, the error is propagated instead.\u003C\u002Fp\u003E\n\u003Ch2 id=\"examples\"\u003E\u003Ca href=\"#examples\" aria-hidden=\"true\"\u003E\u003Cspan class=\"hashtag\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EExamples\u003C\u002Fh2\u003E\n\u003Cp\u003ELet’s look at what the result looks like. We use a Semaphore so that our little test programs doesn’t instantly terminate. We create a source that emits 10 sequential numbers every 200 milliseconds. We delay it until we find a 3 and subscribe to it by printing the results with a timestamp.\u003C\u002Fp\u003E\n\u003Cpre class=\"language-kotlin\"\u003E\u003Ccode class=\"language-kotlin\"\u003E\u003Cspan class=\"token keyword\"\u003Eval\u003C\u002Fspan\u003E mutex \u003Cspan class=\"token operator\"\u003E=\u003C\u002Fspan\u003E \u003Cspan class=\"token function\"\u003ESemaphore\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token number\"\u003E0\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\n\u003Cspan class=\"token keyword\"\u003Eval\u003C\u002Fspan\u003E source \u003Cspan class=\"token operator\"\u003E=\u003C\u002Fspan\u003E Observable\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token function\"\u003Einterval\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token number\"\u003E200\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E,\u003C\u002Fspan\u003E TimeUnit\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003EMILLISECONDS\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token function\"\u003Etake\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token number\"\u003E10\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\n\u003Cspan class=\"token keyword\"\u003Eval\u003C\u002Fspan\u003E delayed \u003Cspan class=\"token operator\"\u003E=\u003C\u002Fspan\u003E  source\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token function\"\u003EdelayUntil\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token number\"\u003E3L\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\n\n\u003Cspan class=\"token function\"\u003Eprintln\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token string-literal singleline\"\u003E\u003Cspan class=\"token string\"\u003E\"\u003C\u002Fspan\u003E\u003Cspan class=\"token interpolation\"\u003E\u003Cspan class=\"token interpolation-punctuation punctuation\"\u003E${\u003C\u002Fspan\u003E\u003Cspan class=\"token expression\"\u003ESystem\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token function\"\u003EcurrentTimeMillis\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"token interpolation-punctuation punctuation\"\u003E}\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"token string\"\u003E: start\"\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\ndelayed\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token function\"\u003Esubscribe\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\n        \u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E \u003Cspan class=\"token function\"\u003Eprintln\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token string-literal singleline\"\u003E\u003Cspan class=\"token string\"\u003E\"\u003C\u002Fspan\u003E\u003Cspan class=\"token interpolation\"\u003E\u003Cspan class=\"token interpolation-punctuation punctuation\"\u003E${\u003C\u002Fspan\u003E\u003Cspan class=\"token expression\"\u003ESystem\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token function\"\u003EcurrentTimeMillis\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"token interpolation-punctuation punctuation\"\u003E}\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"token string\"\u003E: \u003C\u002Fspan\u003E\u003Cspan class=\"token interpolation\"\u003E\u003Cspan class=\"token interpolation-punctuation punctuation\"\u003E$\u003C\u002Fspan\u003E\u003Cspan class=\"token expression\"\u003Eit\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"token string\"\u003E\"\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E,\u003C\u002Fspan\u003E\n        \u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E \u003Cspan class=\"token function\"\u003Eprintln\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token string-literal singleline\"\u003E\u003Cspan class=\"token string\"\u003E\"Failed with \u003C\u002Fspan\u003E\u003Cspan class=\"token interpolation\"\u003E\u003Cspan class=\"token interpolation-punctuation punctuation\"\u003E$\u003C\u002Fspan\u003E\u003Cspan class=\"token expression\"\u003Eit\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"token string\"\u003E\"\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E,\u003C\u002Fspan\u003E\n        \u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E mutex\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token function\"\u003Erelease\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\n\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\n\nmutex\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token function\"\u003Eacquire\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EAnd here’s the output:\u003C\u002Fp\u003E\n\u003Cpre class=\"language-text\"\u003E\u003Ccode class=\"language-text\"\u003E1464210578099: start\n1464210578909: 0\n1464210578909: 1\n1464210578909: 2\n1464210578909: 3\n1464210579106: 4\n1464210579306: 5\n1464210579506: 6\n1464210579706: 7\n1464210579906: 8\n1464210580106: 9\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EWe can see that items 0 through 3 are buffered and then emitted all at once. After that, the remaining items are emitted immediately, just like we wanted to.\u003C\u002Fp\u003E\n\u003Ch2 id=\"making-the-observable-reusable\"\u003E\u003Ca href=\"#making-the-observable-reusable\" aria-hidden=\"true\"\u003E\u003Cspan class=\"hashtag\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EMaking the observable reusable\u003C\u002Fh2\u003E\n\u003Cp\u003ENow what happens if we subscribe to the same delayed observable a second time? The answer is: nothing, it won’t even complete. The problem has to do with how \u003Ccode\u003EConnectableObservables\u003C\u002Fcode\u003E work, but I will spare you the details.\u003C\u002Fp\u003E\n\u003Cp\u003EAnyway, there’s an easy fix. We simply wrap the source with a call to \u003Ccode\u003EObservable.defer\u003C\u002Fcode\u003E to make it compute the results anew on every call:\u003C\u002Fp\u003E\n\u003Cpre class=\"language-kotlin\"\u003E\u003Ccode class=\"language-kotlin\"\u003E\u003Cspan class=\"token keyword\"\u003Eval\u003C\u002Fspan\u003E delayed \u003Cspan class=\"token operator\"\u003E=\u003C\u002Fspan\u003E Observable\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token function\"\u003Edefer\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E source\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token function\"\u003EdelayUntil\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token number\"\u003E3L\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EAlternatively, we can \u003Ccode\u003Ecache\u003C\u002Fcode\u003E the output of the observable to prevent it from doing the same work twice like so:\u003C\u002Fp\u003E\n\u003Cpre class=\"language-kotlin\"\u003E\u003Ccode class=\"language-kotlin\"\u003E\u003Cspan class=\"token keyword\"\u003Eval\u003C\u002Fspan\u003E delayed \u003Cspan class=\"token operator\"\u003E=\u003C\u002Fspan\u003E source\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token function\"\u003EdelayUntil\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token number\"\u003E3L\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token function\"\u003Ecache\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EIn both cases, you can call the observables as many times as you want and get correct behavior.\u003C\u002Fp\u003E\n","date":"25 May 2016","twitter":"","bluesky":"","description":"Using a Kotlin Extension Function to solve an RxJava problem"}},"context":{}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script><script src="/assets/js/app.55ecf81a.js" defer></script><script src="/assets/js/page--src--templates--post-vue.85c2b142.js" defer></script>
  </body>
</html>
