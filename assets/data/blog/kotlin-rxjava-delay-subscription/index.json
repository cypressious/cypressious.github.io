{"hash":"889e1e25681679cf546d20a671f1ef814e228643","data":{"post":{"id":"050fa826b992fe9deebaab7763723d33","title":"RxJava & Kotlin: Conditionally delaying the first item in a stream","content":"<p>In my application, I recently had the following requirement: In a reactive stream of items, wait until one specific item is emitted, then emit all items to the observer. If that item isn’t found, don’t emit anything and terminate with an error.</p>\n<p>Now, RxJava has a number of useful operators like <code>buffer</code> or <code>delaySubscription</code> but they weren’t exactly doing the right thing. So I came up with a solution I want to share.</p>\n<h2 id=\"the-code\"><a href=\"#the-code\" aria-hidden=\"true\"><span class=\"hashtag\"></span></a>The code</h2>\n<p>Here’s the implementation, wrapped in an extension function:</p>\n<pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> Observable<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">.</span><span class=\"token function\">delayUntil</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> T<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Observable<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> replaySubject <span class=\"token operator\">=</span> ReplaySubject<span class=\"token punctuation\">.</span>create<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">val</span> sharedObservable <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">publish</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">autoConnect</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n    sharedObservable<span class=\"token punctuation\">.</span><span class=\"token function\">subscribe</span><span class=\"token punctuation\">(</span>replaySubject<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">val</span> delayObservable <span class=\"token operator\">=</span> sharedObservable\n            <span class=\"token punctuation\">.</span><span class=\"token function\">first</span> <span class=\"token punctuation\">{</span> it <span class=\"token operator\">==</span> value <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">.</span><span class=\"token function\">concatWith</span><span class=\"token punctuation\">(</span>Observable<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span><span class=\"token function\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">return</span> replaySubject<span class=\"token punctuation\">.</span><span class=\"token function\">delaySubscription</span><span class=\"token punctuation\">(</span>delayObservable<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>Let’s analyze what it’s doing:</p>\n<p>Because the items in the stream aren’t delivered immediately at first, we buffer them in a <code>ReplaySubject</code>. As a reminder, a <code>Subject</code> is both, an <code>Observer</code> and an <code>Observable</code>. We make use of this by subscribing it directly to our item source in line 5. Once an observer subscribes to the <code>ReplaySubject</code>, it will emit all previous and future items to it.</p>\n<p>We will need to subscribe to the source observable twice, first to feed the items into the <code>replaySubject</code> and second to check for the expected item. Because the source observable is potentially <a href=\"https://www.javacodegeeks.com/2015/03/hot-and-cold-rx-java-observable.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><em>cold</em></a>, we don’t want to subscribe to it twice directly. Instead, we use the <code>publish</code> operator which will deliver the results from a single stream to all subscribers in combination with the <code>autoConnect</code> operator that makes the observable actually subscribe to the source once two observers are subscribed.</p>\n<p>Next, in lines 7–9, we setup the <code>delayObservable</code> that either emits the first occurence of the expected item in the source stream or terminates with an error. Note, that even if it finds the item, it will still terminate with an error, however that is perfectly fine for our needs.</p>\n<p>This return value of the method is the subject itself with the <code>delaySubscription</code> operator applied to it. This operator expects an observable parameter and waits until it emits any item or completes without emitting before it subscribes to the original observable. This is exactly, what the <code>delayObservable</code> is used for. In our case, if no item is emited, the error is propagated instead.</p>\n<h2 id=\"examples\"><a href=\"#examples\" aria-hidden=\"true\"><span class=\"hashtag\"></span></a>Examples</h2>\n<p>Let’s look at what the result looks like. We use a Semaphore so that our little test programs doesn’t instantly terminate. We create a source that emits 10 sequential numbers every 200 milliseconds. We delay it until we find a 3 and subscribe to it by printing the results with a timestamp.</p>\n<pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> mutex <span class=\"token operator\">=</span> <span class=\"token function\">Semaphore</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">val</span> source <span class=\"token operator\">=</span> Observable<span class=\"token punctuation\">.</span><span class=\"token function\">interval</span><span class=\"token punctuation\">(</span><span class=\"token number\">200</span><span class=\"token punctuation\">,</span> TimeUnit<span class=\"token punctuation\">.</span>MILLISECONDS<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">take</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">val</span> delayed <span class=\"token operator\">=</span>  source<span class=\"token punctuation\">.</span><span class=\"token function\">delayUntil</span><span class=\"token punctuation\">(</span><span class=\"token number\">3L</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token expression\">System<span class=\"token punctuation\">.</span><span class=\"token function\">currentTimeMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">: start\"</span></span><span class=\"token punctuation\">)</span>\ndelayed<span class=\"token punctuation\">.</span><span class=\"token function\">subscribe</span><span class=\"token punctuation\">(</span>\n        <span class=\"token punctuation\">{</span> <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token expression\">System<span class=\"token punctuation\">.</span><span class=\"token function\">currentTimeMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$</span><span class=\"token expression\">it</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">{</span> <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"Failed with </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">$</span><span class=\"token expression\">it</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">{</span> mutex<span class=\"token punctuation\">.</span><span class=\"token function\">release</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">)</span>\n\nmutex<span class=\"token punctuation\">.</span><span class=\"token function\">acquire</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre>\n<p>And here’s the output:</p>\n<pre class=\"language-text\"><code class=\"language-text\">1464210578099: start\n1464210578909: 0\n1464210578909: 1\n1464210578909: 2\n1464210578909: 3\n1464210579106: 4\n1464210579306: 5\n1464210579506: 6\n1464210579706: 7\n1464210579906: 8\n1464210580106: 9</code></pre>\n<p>We can see that items 0 through 3 are buffered and then emitted all at once. After that, the remaining items are emitted immediately, just like we wanted to.</p>\n<h2 id=\"making-the-observable-reusable\"><a href=\"#making-the-observable-reusable\" aria-hidden=\"true\"><span class=\"hashtag\"></span></a>Making the observable reusable</h2>\n<p>Now what happens if we subscribe to the same delayed observable a second time? The answer is: nothing, it won’t even complete. The problem has to do with how <code>ConnectableObservables</code> work, but I will spare you the details.</p>\n<p>Anyway, there’s an easy fix. We simply wrap the source with a call to <code>Observable.defer</code> to make it compute the results anew on every call:</p>\n<pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> delayed <span class=\"token operator\">=</span> Observable<span class=\"token punctuation\">.</span><span class=\"token function\">defer</span> <span class=\"token punctuation\">{</span> source<span class=\"token punctuation\">.</span><span class=\"token function\">delayUntil</span><span class=\"token punctuation\">(</span><span class=\"token number\">3L</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span></code></pre>\n<p>Alternatively, we can <code>cache</code> the output of the observable to prevent it from doing the same work twice like so:</p>\n<pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> delayed <span class=\"token operator\">=</span> source<span class=\"token punctuation\">.</span><span class=\"token function\">delayUntil</span><span class=\"token punctuation\">(</span><span class=\"token number\">3L</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">cache</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre>\n<p>In both cases, you can call the observables as many times as you want and get correct behavior.</p>\n","date":"25 May 2016","twitter":"","description":"Using a Kotlin Extension Function to solve an RxJava problem"}},"context":{}}