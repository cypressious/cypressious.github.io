{"hash":"68e619ada6ef1ac63da036bfefde501c75507779","data":{"post":{"id":"9cf69044816e6cba51f7c95b2ba4a4ef","title":"Kotlin: Emerging Patterns with Context Parameters","content":"<p><a href=\"https://github.com/Kotlin/KEEP/blob/context-parameters/proposals/context-parameters.md\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Context parameters</a> are a new\npreview feature in Kotlin 2.3 and supersede the experimental context receivers. In the Kotlin Compiler codebase, we have\nbeen using this new language feature for a short while, and here I'm sharing some patterns that have emerged so far.</p>\n<h2 id=\"bridge-methods\"><a href=\"#bridge-methods\" aria-hidden=\"true\"><span class=\"hashtag\"></span></a>Bridge Methods</h2>\n<p>An important difference between context receivers and context parameters is that context parameters don't act as\nimplicit receivers.</p>\n<pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">class</span> Foo <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">context</span><span class=\"token punctuation\">(</span>Foo<span class=\"token punctuation\">)</span> <span class=\"token comment\">// context receivers syntax</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">testContextReceiver</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// works</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">context</span><span class=\"token punctuation\">(</span>foo<span class=\"token operator\">:</span> Foo<span class=\"token punctuation\">)</span> <span class=\"token comment\">// context parameters syntax</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">testContextParameter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    foo<span class=\"token punctuation\">.</span><span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// `bar()` would be unresolved, we need to use an explicit receiver</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>This isn't a big deal when we want to call instance methods on the context parameter — we just need to use the name of\nthe context parameter as an explicit receiver of the call.</p>\n<p>However, a problem arises with member extensions (extension functions or properties defined inside an interface or\nclass).</p>\n<pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">class</span> Foo\n\n<span class=\"token keyword\">class</span> Bar <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">fun</span> Foo<span class=\"token punctuation\">.</span><span class=\"token function\">baz</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">context</span><span class=\"token punctuation\">(</span>Bar<span class=\"token punctuation\">)</span> <span class=\"token comment\">// context receivers syntax</span>\n<span class=\"token keyword\">fun</span> Foo<span class=\"token punctuation\">.</span><span class=\"token function\">testContextReceiver</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// works</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">context</span><span class=\"token punctuation\">(</span>bar<span class=\"token operator\">:</span> Bar<span class=\"token punctuation\">)</span> <span class=\"token comment\">// context parameters syntax</span>\n<span class=\"token keyword\">fun</span> Foo<span class=\"token punctuation\">.</span><span class=\"token function\">testContextParameter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">with</span><span class=\"token punctuation\">(</span>bar<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// we need to introduce an implicit receiver of type `Bar` into the scope</span>\n        <span class=\"token function\">baz</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>Having to introduce an implicit receiver using <a href=\"https://kotlinlang.org/api/core/kotlin-stdlib/kotlin/with.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code>with</code></a>\nat every call-site is boilerplate we would like to get rid of.</p>\n<p>One approach is to convert the member extension <code>baz</code> to a contextual top-level extension function.</p>\n<pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token function\">context</span><span class=\"token punctuation\">(</span>bar<span class=\"token operator\">:</span> Bar<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">fun</span> Foo<span class=\"token punctuation\">.</span><span class=\"token function\">baz</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">context</span><span class=\"token punctuation\">(</span>bar<span class=\"token operator\">:</span> Bar<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">fun</span> Foo<span class=\"token punctuation\">.</span><span class=\"token function\">testContextParameter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">baz</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// works</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>However, this only works when the method doesn't need to be overridden — a common use case for us. In this case, we can\nduplicate the method as a top-level extension (the so-called <strong>bridge method</strong>) and delegate the implementation to the\ninterface.</p>\n<pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">interface</span> Bar <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">fun</span> Foo<span class=\"token punctuation\">.</span><span class=\"token function\">baz</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> BarImpl1 <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> Foo<span class=\"token punctuation\">.</span><span class=\"token function\">baz</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> BarImpl2 <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> Foo<span class=\"token punctuation\">.</span><span class=\"token function\">baz</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">context</span><span class=\"token punctuation\">(</span>bar<span class=\"token operator\">:</span> Bar<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">fun</span> Foo<span class=\"token punctuation\">.</span><span class=\"token function\">baz</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token function\">with</span><span class=\"token punctuation\">(</span>bar<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token function\">baz</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span> <span class=\"token comment\">// delegates to the member extension</span>\n\n<span class=\"token function\">context</span><span class=\"token punctuation\">(</span>bar<span class=\"token operator\">:</span> Bar<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">fun</span> Foo<span class=\"token punctuation\">.</span><span class=\"token function\">testContextParameter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">baz</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// works</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>We traded some boilerplate on the call-site against some boilerplate on the declaration side. In practice, it's still\nworth it because the number of call-sites is typically more than one.</p>\n<p>The manual work of writing bridge methods looks like a good candidate for automation, e.g., using the IDE or a compiler\nplugin.</p>\n<h2 id=\"holder-pattern\"><a href=\"#holder-pattern\" aria-hidden=\"true\"><span class=\"hashtag\"></span></a>Holder Pattern</h2>\n<p>The value that we would like to pass around as a context argument needs to come from somewhere. Everything just works\nwhen it's passed as a context parameter or extension receiver to us. In this case, the compiler will pick it up and\nuse it as a context argument for other calls.</p>\n<pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token function\">context</span><span class=\"token punctuation\">(</span>bar<span class=\"token operator\">:</span> Bar<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">fun</span> Foo<span class=\"token punctuation\">.</span><span class=\"token function\">baz</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">context</span><span class=\"token punctuation\">(</span>bar<span class=\"token operator\">:</span> Bar<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span>foo<span class=\"token operator\">:</span> Foo<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    foo<span class=\"token punctuation\">.</span><span class=\"token function\">baz</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// works</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> Bar<span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span>foo<span class=\"token operator\">:</span> Foo<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    foo<span class=\"token punctuation\">.</span><span class=\"token function\">baz</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// also works</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>But sometimes we're working with a class where the value is stored in a property. To make the value available as\npotential context argument, we need to bring it into scope, e.g., using the new <a href=\"https://kotlinlang.org/api/core/kotlin-stdlib/kotlin/context.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code>context</code></a> function.</p>\n<pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token function\">context</span><span class=\"token punctuation\">(</span>bar<span class=\"token operator\">:</span> Bar<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">fun</span> Foo<span class=\"token punctuation\">.</span><span class=\"token function\">baz</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token function\">C</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">val</span> bar<span class=\"token operator\">:</span> Bar<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span>foo<span class=\"token operator\">:</span> Foo<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">context</span><span class=\"token punctuation\">(</span>bar<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            foo<span class=\"token punctuation\">.</span><span class=\"token function\">baz</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>To get rid of this boilerplate, we can introduce a <strong>holder</strong> interface for our contextual type <code>Bar</code> that our classes\n(typically more than one) can implement.</p>\n<pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">interface</span> BarHolder <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> bar<span class=\"token operator\">:</span> Bar\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">context</span><span class=\"token punctuation\">(</span>holder<span class=\"token operator\">:</span> BarHolder<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">fun</span> Foo<span class=\"token punctuation\">.</span><span class=\"token function\">baz</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    holder<span class=\"token punctuation\">.</span>bar <span class=\"token comment\">// we can retrieve `Bar` from `holder`</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token function\">C</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">override</span> <span class=\"token keyword\">val</span> bar<span class=\"token operator\">:</span> Bar<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> BarHolder <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span>foo<span class=\"token operator\">:</span> Foo<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// the dispatch receiver `C` is a subtype of `BarHolder`,</span>\n        <span class=\"token comment\">// and is used as a context argument</span>\n        foo<span class=\"token punctuation\">.</span><span class=\"token function\">baz</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>This is really more of a workaround than a pattern, and the team is actively thinking about how to better accommodate\nthis use case. Follow <a href=\"https://youtrack.jetbrains.com/issue/KT-79236/Class-properties-that-contribute-context-arguments-to-the-class-scope\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">KT-79236</a> for more updates. </p>\n<h2 id=\"deprecated-overloads-for-gradual-migration\"><a href=\"#deprecated-overloads-for-gradual-migration\" aria-hidden=\"true\"><span class=\"hashtag\"></span></a>Deprecated Overloads for Gradual Migration</h2>\n<p>Sometimes, we want to convert a parameter to a context parameter. We can use the <strong>Change Signature</strong> refactoring in\nIntelliJ IDEA (support is available starting from 2025.2 though in 2025.3 it will be more mature), and it will migrate\nall call-sites.</p>\n<p>But sometimes we can't or don't want to migrate all call-sites immediately. In this case, we can introduce an overload\nand let callers migrate gradually.</p>\n<pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>bar<span class=\"token operator\">:</span> Bar<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">context</span><span class=\"token punctuation\">(</span>bar<span class=\"token operator\">:</span> Bar<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>bar<span class=\"token punctuation\">)</span> <span class=\"token comment\">// delegate to non-contextual overload</span>\n\n<span class=\"token function\">context</span><span class=\"token punctuation\">(</span>bar<span class=\"token operator\">:</span> Bar<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// bar is available as a context argument</span>\n    <span class=\"token comment\">// can be replaced with `foo()`</span>\n    <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>bar<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>To detect call-sites that already have the required context argument in scope, we can introduce a third overload\nthat takes both a context parameter and a regular parameter and is marked as deprecated.</p>\n<pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>bar<span class=\"token operator\">:</span> Bar<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">context</span><span class=\"token punctuation\">(</span>bar<span class=\"token operator\">:</span> Bar<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>bar<span class=\"token punctuation\">)</span> <span class=\"token comment\">// delegate to non-contextual overload</span>\n\n<span class=\"token annotation builtin\">@Deprecated</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"use parameterless overload\"</span></span><span class=\"token punctuation\">,</span> replaceWith <span class=\"token operator\">=</span> <span class=\"token function\">ReplaceWith</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"foo()\"</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">context</span><span class=\"token punctuation\">(</span>_<span class=\"token operator\">:</span> Bar<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> Bar<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>bar <span class=\"token operator\">=</span> x<span class=\"token punctuation\">)</span>\n\n<span class=\"token function\">context</span><span class=\"token punctuation\">(</span>bar<span class=\"token operator\">:</span> Bar<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>bar<span class=\"token punctuation\">)</span> <span class=\"token comment\">// Deprecation warning: use parameterless overload</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span>bar<span class=\"token operator\">:</span> Bar<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>bar<span class=\"token punctuation\">)</span> <span class=\"token comment\">// resolves to non-contextual overload, no deprecation warning.</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>Using IntelliJ IDEA, we can migrate all callers of the deprecated method inside our project to the first overload.  </p>\n<p><img class=\"g-image g-image--lazy g-image--loading\" src=\"data:image/svg+xml,%3csvg fill='none' viewBox='0 0 730 246' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-df6a709b1f3de51be24268bb58d343ab'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-df6a709b1f3de51be24268bb58d343ab)' width='730' height='246' xlink:href='data:image/png%3bbase64%2ciVBORw0KGgoAAAANSUhEUgAAAEAAAAAWCAYAAABwvpo0AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAGyElEQVRYw91YaXPjxhHV/6/Kj3Cl/MFx%2bcjGTlK2Yzt72WspEiVKvHDfAAECBEACIADi5c1wpTCrOFmvtaUkqOqawRw9Mz19vJ6TOBhjnRooMlNSlsyRRBMsQw9hEEBRFJiWDU1VsVgoCKMQWbZGXMYwViaCIkKQ%2b9ASHSrpyr%2bBEmtw1y4WywWM1MK6LjkmgJ4Y0FYWTLZNoxmcLMCw38M2dEwmM5imDk3TML65ga7NYBguqrrGMoowvhrLPlVZsM/AbD7jnBuYhoXVKmFpQNd17tWCwdLgv23biJYxik2BsTHGj9NXuLbGUJca/NBHti5wUuUWqk2Atlmh3oSyLihLV9hWFdbrjAukchOe76MoS9TcVNPWsDOXh1vLw/kkj2SsbIQUSlatEbH085BjCsSbhP8hVmx3156cm3NjbdtitVzy8BaCwIfneoeN8wKSOJVrFUUByzDhui77bfh%2bCMdxWPrcV4yyLKQQluSTZhniOOb/iheVodxs0HGNdJNiZk%2bheAqSIuH5MuRFiRPF7jBebDAzG8yVGJObKSZzFU3dYDGd4ZKSj7jI/%2bt3UpQ9kqyGE1SU2pZS95HnGfq%2bR1nkUhMqaoK4qa7r0DSNvBWpBazvdjvU1Ia279BTnft9j6arZdue/4IELzG/5XzBo6oratcW2%2b1W9g/DgF1L3rKfY/u95CXaxVwxR8zf7we2Hdrfhfb/Yu7JTK8Qphs8Hbk4HeuwtW%2bRLq8Q2j/SH8zoFxRE7jXiJME6z2lfGqazGabTKdXWpLoltLEci0ih/U9wHdzgzL2El0SIgpC2FiDyfDx//hyaTh%2bTpgjDkPas0mYNKcicqqqGMU41ExPVxczrsMwpkB4IqO6nP51yXRVV08lbu938cf1d6YQCRtcPvJGeN73Drtmg73ZodxWl31HqvfzvXt%2beuJH%2b6GZFCe5F3HzH8YL2gvl%2beD22v7vJ29u8rd9qiKC2E/P3h3V6sTlIkut0r8cfHfrBTOAhmAwY3pOF3uf7kIeXAghTwPS3cKIarpfCsS3p7YV9B54Hix5ZhD38SlV7N7qv4g%2buAZ5yDsMpYAc7hphU2ppB2941Ozgs54sF7X/1sxv6X6cT78VvUG4LGHRyBh2UH0ao6J2z9frfqOWbhLdsG37B/OFnzeBBTcBPgGLb0mtvEOU1/IAgZp0TUKzpwIQTOjjJ/qjcS6eHo/pw13ZbirH3x90vDzTcrXVcHvM9rC2c6cPSiVBrO8rx5fMZXp4vEBF9WY6PcJni/HyMV6eX0K0Qy6RARLKcCIruwHIj2C4RnBPCsCNZxgynukm/wXbbi1l3EQlsIdotX84X48RclTxU0z/w4VjbW8INVsQk27s2j/%2b6RX6sl9WATb1H%2bcAkw2BWEgj5K%2bKBFpuGoGTXEpgQCG0qQt8KG4bHpmWoosSqpmXIJBhiTK5ZL7c1%2bxtZVnXL8QQ4HF/VO2pSKeeKermpZfuBX0PswHLbyDZBoi7mN7tejj/w79h%2b4Nt2w3uhk30n4nR/MIj0KfrViLefSfxdEPhsiaWbhmCFOUFK/LzdlMwP2L7dECkWD2aLEk/8wpD4YDig61r5UwWvUMVTjMcToq8zXJxfMBe4gsuweD0aMUubEyanuGT/nJmh7we/LsoP/3B0Xd8/ThQ4SL9ltgZ4yg%2bwNB5%2bVmC0yHA%2bW2GkrDG1a4y1DS6VHBfzDBOrxgX7L9n36jrGpZrjxYWNs0kix4zma1xpJU6vlzi7iclD8FvLuX%2bbphwXQ/H3UIMBE7tFtIZEnO8jzr%2bVBgwUgJ8Dk4tnuLoc4cMn5/jw81N89Icz/O5PI3zzg4VPv7rGbz99iQ8%2beYk/PjPw5PsFnl2E%2bOSrCb54quKDj7/HR1%2bO8O1PAb5%2bYeKLv6r47OspPvvzFT7/ZoInf5njyXdTyff33zHLNHqMrQGnC%2bKN5JEFIDE6Y025oxl0963utuyHA91a65ulHEOiv8RO5BgifHH8jjxFHiPaBIn%2beicc6l6ScEZ9/4gCEPYnYR6P2rcNDEPHbDLFchlJZKirinyMiERmx0wuCjxoigrPsuXLi%2b%2b7/FfkPItQWqTIMkMYRKK0v%2bN9gJKv294APY8ugNtFRTbmug50TZcvJpZpwDLEU5MjX1jES4t4rXEcD6Hry9TYtEzYFIbjuARSASNEfZSq4j/SrRb%2bVwhAPDwE9PoBD%2bIHPmzbke8ASRLL25eH9MTTlUNBefBJAjX6niv7RKg8PsTbeOLHFcDwz4sLDXCYAQoNcIQm6AYS3rrrOFIwk5sJTMOU6q6qGlVfk48lwgRE4uRROG8%2bWrxNKHwsAfwdr2lRKd1AiTgAAAAASUVORK5CYII=' /%3e%3c/svg%3e\" width=\"730\" alt=\"IntelliJ IDEA suggests replacing calls to the deprecated method in the whole project\" data-srcset=\"/assets/static/replace-deprecated.df92f3f.249e4f784dd1b0fc0dd8ab4ae8cafcb7.png 730w\" data-sizes=\"(max-width: 730px) 100vw, 730px\" data-src=\"/assets/static/replace-deprecated.df92f3f.249e4f784dd1b0fc0dd8ab4ae8cafcb7.png\"><noscript><img class=\"g-image g-image--lazy g-image--loaded\" src=\"/assets/static/replace-deprecated.df92f3f.249e4f784dd1b0fc0dd8ab4ae8cafcb7.png\" width=\"730\" alt=\"IntelliJ IDEA suggests replacing calls to the deprecated method in the whole project\"></noscript></p>\n<h2 id=\"force-resolution-to-non-contextual-overload\"><a href=\"#force-resolution-to-non-contextual-overload\" aria-hidden=\"true\"><span class=\"hashtag\"></span></a>Force Resolution to Non-Contextual Overload</h2>\n<p>When the compiler resolves a call, and it has the choice between a contextual and non-contextual overload, it will\nprioritize the contextual one. This can be demonstrated by altering the previous example.</p>\n<pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>bar<span class=\"token operator\">:</span> Bar<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">context</span><span class=\"token punctuation\">(</span>_<span class=\"token operator\">:</span> Bar<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>bar<span class=\"token operator\">:</span> Bar<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// both overloads are applicable, prioritizing the contextual one</span>\n    <span class=\"token comment\">// oops, infinite recursion</span>\n    <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>bar<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>We can force the compiler to resolve to the non-contextual overload by using different parameter names (like in the\nexample above) and using the named argument syntax.</p>\n<pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>bar<span class=\"token operator\">:</span> Bar<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">context</span><span class=\"token punctuation\">(</span>_<span class=\"token operator\">:</span> Bar<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>x<span class=\"token operator\">:</span> Bar<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// only one overload is applicable, no recursion</span>\n    <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span>bar <span class=\"token operator\">=</span> x<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"closing\"><a href=\"#closing\" aria-hidden=\"true\"><span class=\"hashtag\"></span></a>Closing</h2>\n<p>Part of the reason why context parameters are released in preview is to collect problems like the ones highlighted in\nthis post. This way, the team can make adjustments and implement improvements before releasing them as stable.</p>\n<p>Let us know in the <a href=\"https://github.com/Kotlin/KEEP/issues/367\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">KEEP discussion</a> if you discovered any more problems or\nshare your favorite patterns in the Bluesky thread.</p>\n","date":"29 August 2025","twitter":"","bluesky":"https://bsky.app/profile/rakhman.info/post/3lxjtksiujk2q","description":"Early patterns with Kotlin 2.3’s new context parameters. Key takeaways include bridge methods for member extensions, the holder pattern, and deprecated overloads for gradual migration."}},"context":{}}